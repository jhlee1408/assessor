---
title: "Manual of assesor"
output: rmarkdown::html_vignette
vignette: >
  \VignetteIndexEntry{assesor}
  \VignetteEngine{knitr::knitr}
  \VignetteEncoding{UTF-8}{inputenc}
---

## Introduction
Assessor is a package that provides tools for assessing the assumptions of regression models with discrete, zero-inflated, and semi-continuous outcomes. Users can calculate the double probability integral transform (DPIT) residuals and draw QQ-plots via the DPIT residuals. 

## Installation
Like other R packages, `assessor` can be installed directly from CRAN.(I hope so.) Type the following command: 
```{r installation, eval=FALSE}
install.packages("assessor")
```

## General function arguments
In `assessor`, there are functions for assessing DPIT residuals for the various type of models: discrete, zero-inflated, and semi-continuous outcome regression models. `resid_disc()`, `resid_zeroinfl()`, `resid_semiconti()` and `resid_2pm()` are functions evaluating DPIT residuals. 
They share the same arguments:

* `model`: Each function supports different types of model objects. Check below which model objects are applicable.

* `plot`:If you set `plot=T`, a function will return QQ-plot drawn with DPIT residuals, or vice versa. 
Some users may only need the QQ-plot. In that case, `qqresdi()` only returns the QQ-plot without returning the DPIT residuals.

* `scale`: You can choose the scale of the residuals among `normal` and `uniform` scales. The sample quantiles of the residuals are plotted against the theoretical quantiles of a standard normal distribution under the normal scale, and against the theoretical quantiles of a uniform (0,1) distribution under the uniform scale. The defalut scale is `normal`



### `resid_disc()`
`resid_disc()` is used for calculating the DPIT residuals for regression models with discrete outcomes and drawing corresponding QQ-plots. The suitable model objects are as follows: 

* Poisson, `glm(formula, family=poisson(link="log"))` 
* Binary, `glm(, family=binomial(link="logit"))` 
* Negative Binomial, `MASS::glm.nb()` 
* Ordinal, `MASS::polr()` 

```{r discrete outcomes poi, fig.align = 'center', eval=FALSE, warning=FALSE}

```

### `resid_zeroinfl()`
`resid_zeroinfl()` is used for caclulating the DPIT residuals for regression models with zero-inflated discrete outcome. Applicable model objects are as follows:

*


```{r zeroinflated outcomes}

```

### `resid_semiconti()`
`resid_semiconti()` is used for assessing for regression models with semi-continuous outcomes. Particularly, the model object for a Tobit regression model derived by `VGAM` and `AER` packages and for a Tweedie regression derived by `tweedie` package is applicable. 

* Tweedie,`glm(formula,family = tweedie())`
* Tobit(VGAM), `vglm(formula, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))` 
* Tobit(AER), `tobit(formula,left = 0,right = Inf, dist = "gaussian")`

```{r semiconti}
library(assessor)
### Tobit
n <- 500

#### Parameter
beta0 <- 2
beta1 <- 2
beta2 <- 2

#### Covariates
set.seed(1234)
x11 <- runif(n, -1, 1)
x12 <- runif(n, -1, 1)
lambda1 <- beta0 + beta1 * x11 + beta2 * x12
sd0 <- 0.2
#### Latent variable
yun <- rnorm(n, mean = lambda1, sd = sd0)
#### Response
y <- ifelse(yun >= 0, yun, 0)
```

```{r Tobit}
##### True model
library(VGAM)
fit1 <- vglm(y ~ x11 + x12, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))

resid_semiconti(fit1, scale = "uniform")
```

```{r Tobit missing covariate}
##### Missing covariate
fit1miss <- vglm(y ~ x11, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))
resid_semiconti(fit1miss)
```

```{r Tobit copula}
### Correlated covariates
library(copula)
n <- 500

beta0 <- 2
beta1 <- 2
beta2 <- 2

set.seed(1234)

##### Simulate correlated covariates
u <- rCopula(n, normalCopula(param = 0.3))
x11 <- qunif(u[, 1], -1, 1)
x12 <- qunif(u[, 2], -1, 1)
lambda1 <- beta0 + beta1 * x11 + beta2 * x12
sd0 <- 0.2
yun <- rnorm(n, mean = lambda1, sd = sd0)
y <- ifelse(yun >= 0, yun, 0)


##### True model
fit1 <- vglm(y ~ x11 + x12, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))
resid_semiconti(fit1, scale = "uniform")

##### Missing covariate
fit1miss <- vglm(y ~ x11, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))
resid_semiconti(fit1miss)
```


```{r tobit with interaction}
### Tobit with interaction
n <- 500

#### Parameters
beta0 <- 2
beta1 <- 2
beta2 <- 2
beta3 <- 3

set.seed(1234)
x11 <- runif(n, -1, 1)
x12 <- runif(n, -1, 1)
lambda1 <- beta0 + beta1 * x11 + beta2 * x12 + beta3 * x11 * x12
sd0 <- 0.2
#### Latent variable
yun <- rnorm(n, mean = lambda1, sd = sd0)
#### Response
y <- ifelse(yun >= 0, yun, 0)


##### True model
fit1 <- vglm(y ~ x11 * x12, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))
resid_semiconti(fit1)

#### Missing interaction
fit1miss <-
  vglm(y ~ x11 + x12, tobit(Upper = Inf, Lower = 0, lmu = "identitylink"))
resid_semiconti(fit1miss, scale = "normal")
resid_semiconti(fit1miss, scale = "uniform")
```


```{r AER package Tobit}
### One can also use AER package
library(AER)
fit2 <- tobit(y ~ x11 + x12,
              left = 0,
              right = Inf,
              dist = "gaussian")
resid_semiconti(fit2, scale = "uniform")
```

```{r Tweedie}
### Tweedie
library(tweedie)
library(statmod)
n = 500
set.seed(1234)

x11 <- rnorm(n)
x12 <- rnorm(n)

beta0 <- 5
beta1 <- 1
beta2 <- 1


lambda1 <- exp(beta0 + beta1 * x11 + beta2 * x12)


set.seed(1234)
y1 <- rtweedie(n, mu = lambda1, xi = 1.6, phi = 10)

xi.vec <- seq(1.1, 1.9, by = 0.1)
#### Choose parameter p
out.model <-
  tweedie.profile(y1 ~ x11 + x12,
                  xi.vec = xi.vec,
                  do.plot = FALSE,
                  verbose = FALSE)

#### True model
model1 <-
  glm(y1 ~ x11 + x12,
      family = tweedie(var.power = out.model$xi.max, link.power = 0))
resid_semiconti(model1)
```

### `resid_2pm()`


```{r resid2_pm}
```


### `ord_curve()`
```{r }

```


