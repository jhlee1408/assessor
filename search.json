[{"path":"https://jhlee1408.github.io/assessor/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 residuals authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jhlee1408.github.io/assessor/articles/2pm.html","id":"two-part-models","dir":"Articles","previous_headings":"","what":"Two part models","title":"Two part","text":"input arguments resid_2pm() function differ functions assessor package. Specifically, users can utilize function either models Probability Integral Transform (PIT) input. instance, evaluating distribution assumptions two-part model combines logistic gamma regression, provide logistic regression model object argument model0 gamma regression model object model1. recommend utilizing model input assessing gamma + logistic two-part model. Alternatively, users can directly use PIT input two-part model gamma+logistic combination. cases, users first calculate PIT input part0 part1, respectively. function accommodates two combinations: either model0 conjunction model1 part0 conjunction part1. Note essential specify y (outcome) values function arguments. underlying model two-part model. probability zero \\[p_0(\\mathbf{X})=\\text{logit}^{-1}\\left(\\beta_0+X_{1}\\beta_{1}+X_{2}\\beta_{2} \\right),\\] \\(X_1\\) standard normal variable, \\(X_2\\) binary probability one 0.4, \\((\\beta_0,\\beta_{1},\\beta_{2})=(1,-2,-1)\\). gamma distribution employed generate positive data. mean function positive part described \\[\\lambda_S=\\exp\\left(\\beta_{0S}+\\beta_{1S}X_1+\\beta_{2S}X_2\\right).\\] let \\((\\beta_{0S},\\beta_{1S},\\beta_{2S})=(-1,-1,-2)\\). dispersion parameter set 0.5. Models input PIT input","code":"library(assessor) library(MASS) n <- 500 beta10 <- 1 beta11 <- -2 beta12 <- -1 beta13 <- -1 beta14 <- -1 beta15 <- -2 x11 <- rnorm(n) x12 <- rbinom(n, size = 1, prob = 0.4)  p1 <- 1 / (1 + exp(-(beta10 + x11 * beta11 + x12 * beta12))) lambda1 <- exp(beta13 + beta14 * x11 + beta15 * x12) y2 <- rgamma(n, scale = lambda1 / 2, shape = 2) y <- rep(0, n) u <- runif(n, 0, 1) ind1 <- which(u >= p1) y[ind1] <- y2[ind1] # models as input mgamma <- glm(y[ind1] ~ x11[ind1] + x12[ind1], family = Gamma(link = \"log\")) # Gamma regression m10 <- glm(y == 0 ~ x12 + x11, family = binomial(link = \"logit\")) # logistic regression  resid.models <- resid_2pm(model0 = m10, model1 = mgamma, y = y) library(assessor) library(MASS) n <- 500 beta10 <- 1 beta11 <- -2 beta12 <- -1 beta13 <- -1 beta14 <- -1 beta15 <- -2 x11 <- rnorm(n) x12 <- rbinom(n, size = 1, prob = 0.4)  p1 <- 1 / (1 + exp(-(beta10 + x11 * beta11 + x12 * beta12))) lambda1 <- exp(beta13 + beta14 * x11 + beta15 * x12) y2 <- rgamma(n, scale = lambda1 / 2, shape = 2) y <- rep(0, n) u <- runif(n, 0, 1) ind1 <- which(u >= p1) y[ind1] <- y2[ind1]  # PIT as input mgamma <- glm(y[ind1] ~ x11[ind1] + x12[ind1], family = Gamma(link = \"log\")) # gamma regression m10 <- glm(y == 0 ~ x12 + x11, family = binomial(link = \"logit\")) # logistic regression  cdfgamma <- pgamma(y[ind1],   scale = mgamma$fitted.values * gamma.dispersion(mgamma),   shape = 1 / gamma.dispersion(mgamma) ) p1f <- m10$fitted.values  resid.pit <- resid_2pm(part0= p1f, part1 = cdfgamma, y = y)"},{"path":"https://jhlee1408.github.io/assessor/articles/assessor.html","id":"assessor","dir":"Articles","previous_headings":"","what":"assessor","title":"Introduction to assessor","text":"goal assessor provide assessment tools regression models discrete semicontinuous outcomes proposed Yang (2024) Yang(2024). calculates double probability integral transform (DPIT) residuals, constructs QQ plots residuals model diagnostics, constructs ordered curve assessing mean structures.","code":""},{"path":"https://jhlee1408.github.io/assessor/articles/assessor.html","id":"general-function-arguments","dir":"Articles","previous_headings":"assessor","what":"General function arguments","title":"Introduction to assessor","text":"assessor, functions calculating DPIT residuals various type models: discrete, zero-inflated, semi-continuous outcome regression models. resid_disc(), resid_zeroinfl(), resid_semiconti(), resid_2pm() functions evaluating DPIT residuals discrete, zero-inflated discrete, semicontinuous, two-part outcomes, respectively. share arguments: model: function supports certain types model objects. Check model objects applicable. plot: set plot=TRUE, function return QQ-plot DPIT residuals. users may need QQ-plot. case, qqresid() returns QQ-plot without returning DPIT residuals. scale: can choose scale residuals among normal uniform scales. sample quantiles residuals plotted theoretical quantiles standard normal distribution normal scale, theoretical quantiles uniform (0,1) distribution uniform scale. default scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/articles/assessor.html","id":"real-data-example","dir":"Articles","previous_headings":"assessor","what":"Real data example","title":"Introduction to assessor","text":"solder data, extracted faraway package, lends fitting either Poisson regression Negative Binomial regression. selection models depends underlying distribution characteristics data. validate distribution assumption, comprehensive approach involves assessing DPIT residuals scrutinizing QQ plot derived residuals.  left panel figure presents QQ plot DPIT residuals use Poisson GLM (modp). residuals display pronounced S-shaped pattern, hinting potential overdispersion. second third panels present DPIT residuals negative binomial regression (modpnb) different scales. plots align closely along diagonal line, suggesting assumption negative binomial distribution appears appropriate. distinction lies scale parameter; middle panel displays plot normal scale, \\(x\\) \\(y\\) axes spanning beyond (0,1), right panel limits axes range 0 1.","code":"library(assessor) library(faraway)  library(MASS) data(\"solder\") # from faraway package   ## Negative Binomial modpnb <- glm.nb(skips~.,data=solder) modp <- glm(skips~.,famil=poisson(link=\"log\"),data=solder)  ## QQ-plot par(mfrow=c(1,3)) poi.resid <- resid_disc(modp,plot = TRUE) norm.resid <- resid_disc(modpnb,plot = TRUE, scale = \"normal\") unif.resid <- resid_disc(modpnb,plot = TRUE, scale = \"uniform\")"},{"path":"https://jhlee1408.github.io/assessor/articles/disc.html","id":"discrete-outcome-regression-models","dir":"Articles","previous_headings":"","what":"Discrete outcome regression models","title":"Discrete","text":"resid_disc() used calculating DPIT residuals regression models discrete outcomes constructing QQ-plots. suitable model objects follows: Negative binomial, MASS::glm.nb() Poisson, glm(formula, family=poisson(link=\"log\")) Binary, glm(formula, family=binomial(link=\"logit\")) Ordinal, MASS::polr() Negative binomial Poisson Binary Ordinal example usage resid_disc() function negative binomial regression included . data generated using negative binomial distribution mean \\(\\mu = \\exp\\left(\\beta_0 +X_1\\beta_1+X_2\\beta_2\\right)\\), \\(X_1 \\sim N(0,1)\\), \\(X_2\\) binary probability success 0.7. coefficients set \\(\\beta_0 = -2, \\beta_1 = 2\\), \\(\\beta_2=1\\). underlying size parameter 2. assess model assumptions, one can employ QQ-plot generated either reisd_disc() qqresid(). model1 correctly specified GLM negative binomial distribution, whereas model2 incorrectly assumes Poisson family, thus overdispersion present. left panel displays diagonal QQ-plot along straight red line, indicative model assumption holding. contrast, right panel deviates diagonal line, suggesting lack adherence assumption. addition, overdispersed model, due underestimated variance, S-shaped pattern presents QQ-plot. Similarly, can simulate Poisson random variable using covariates \\(x_1\\) \\(x_2\\). true mean \\(Y\\) intricately connected \\(x_1\\) \\(x_2\\), expressed ensuing relationship: \\[ Y \\sim \\text{Poisson}(\\lambda = \\exp(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2)), \\] \\(\\beta_0=-2,~\\beta_1=2,~\\beta_2=1\\). manually enlarged three outcomes adding values 10, 15, 20 , respectively. right panel, can see three modified data points stand , signaling potential outliers.  binary example, generate Bernoulli random variable, \\(Y\\), whose mean depends covariates \\(x_1\\) \\(x_2\\). underlying model logistic regression probability 1 \\(\\mathrm{logit}^{-1}(\\beta_0+\\beta_1 X_1+\\beta_2 X_2+\\beta_3X_1 X_2)\\), \\((\\beta_0,\\beta_1,\\beta_2,\\beta_3)=(-5,2,1,3)\\), \\(X_1\\sim N(1,1)\\), \\(X_2\\) dummy variable probability one equal 0.7. misspecified model, binary covariate interaction term omitted. true model, distinguished model1, visually represented left panel, showcasing alignment red diagonal line. alignment serves indicator model’s adherence expected pattern. hand, model2, made without inclusion variable \\(x_2\\) interaction, presents deviation prescribed red diagonal line. resid_disc() function also applicable ordinal regression fitted MASS::polr(). experiment, consider ordinal regression models three levels 0, 1, 2. ordinal logistic regression model proportionality assumption, \\(P(Y\\leq j)=F(\\alpha_j),\\) \\(F\\) distribution function logistic random variable mean \\(\\beta_1x_1\\). let \\(\\alpha_0=1\\), \\(\\alpha_1=4\\), \\(\\beta_1=3\\), \\(x_1\\sim N(2,1)\\). Specifically, \\(P(Y\\leq 0)=F(\\alpha_0)\\) described whereas \\(P(Y\\leq 1)=F_1(\\alpha_1)\\), \\(F_1\\) distribution function logistic random variable mean \\(\\beta_2x_1\\) set \\(\\beta_2=1\\). data incorrectly fit proportional odds model. result, considering diagnostic assessment QQ-plots, model1 exhibits diagonal QQ-plot, indicating favorable alignment underlying assumptions. contrast, QQ-plot associated model2 deviates expected diagonal line, suggesting departure idealized model assumptions. discrepancy underscores importance careful consideration inclusion relevant variables model specification ensure robustness validity statistical models.","code":"library(assessor) library(MASS) n <- 500 set.seed(1234) ## Negative Binomial example # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7)  ### Parameters beta0 <- -2 beta1 <- 2 beta2 <- 1 size1 <- 2 lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2)  # generate outcomes y <- rnbinom(n, mu = lambda1, size = size1) par(mfrow=c(1,2)) # True model model1 <- glm.nb(y ~ x1 + x2) resd1 <- resid_disc(model1, plot = TRUE, scale = \"normal\")  # Overdispersion model2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resd2 <- resid_disc(model2, plot = TRUE, scale = \"normal\") ## Poisson example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7)  # Coefficients beta0 <- -2 beta1 <- 2 beta2 <- 1 lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) y <- rpois(n, lambda1) par(mfrow=c(1,2)) # True model poismodel1 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid1 <- resid_disc(poismodel1, plot = TRUE)  # Enlarge three outcomes y <- rpois(n, lambda1) + c(rep(0, (n - 3)), c(10, 15, 20)) poismodel2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid2 <- resid_disc(poismodel2, plot = TRUE) ## Binary example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n, 1, 1) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -5 beta1 <- 2 beta2 <- 1 beta3 <- 3 q1 <- 1 / (1 + exp(beta0 + beta1 * x1 + beta2 * x2 + beta3 * x1 * x2))  y1 <- rbinom(n, size = 1, prob = 1 - q1) par(mfrow=c(1,2)) # True model model01 <- glm(y1 ~ x1 * x2, family = binomial(link = \"logit\")) resid1 <- resid_disc(model01, plot = TRUE)  # Missing covariates model02 <- glm(y1 ~ x1, family = binomial(link = \"logit\")) resid2 <- resid_disc(model02, plot = TRUE) ## Ordinal example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n, mean = 2) # Coefficient beta1 <- 3  # True model p0 <- plogis(1, location = beta1 * x1) p1 <- plogis(4, location = beta1 * x1) - p0 p2 <- 1 - p0 - p1 genemult <- function(p) {   rmultinom(1, size = 1, prob = c(p[1], p[2], p[3])) } test <- apply(cbind(p0, p1, p2), 1, genemult) y1 <- rep(0, n) y1[which(test[1, ] == 1)] <- 0 y1[which(test[2, ] == 1)] <- 1 y1[which(test[3, ] == 1)] <- 2 multimodel <- polr(as.factor(y1) ~ x1, method = \"logistic\") We then generate data under the scenario where the assumption of proportionality is not met, which is a common issue for ordinal regression models. ## Non-Proportionality n <- 500 set.seed(1234) x1 <- rnorm(n, mean = 2) beta1 <- 3 beta2 <- 1 p0 <- plogis(1, location = beta1 * x1) p1 <- plogis(4, location = beta2 * x1) - p0  p2 <- 1 - p0 - p1 genemult <- function(p) {   rmultinom(1, size = 1, prob = c(p[1], p[2], p[3])) } test <- apply(cbind(p0, p1, p2), 1, genemult) y1 <- rep(0, n) y1[which(test[1, ] == 1)] <- 0 y1[which(test[2, ] == 1)] <- 1 y1[which(test[3, ] == 1)] <- 2 multimodel2 <- polr(as.factor(y1) ~ x1, method = \"logistic\") par(mfrow=c(1,2)) resid1 <- resid_disc(multimodel, plot = TRUE) resid2 <- resid_disc(multimodel2, plot = TRUE)"},{"path":"https://jhlee1408.github.io/assessor/articles/ord.html","id":"assessing-the-mean-structure","dir":"Articles","previous_headings":"","what":"Assessing the mean structure","title":"Ordered curve","text":"ord_curve()creates plot assess mean structure regression models. plot compares cumulative sum response variable hypothesized value. Deviation diagonal suggests possibility mean structure model incorrect. Ordered curve method restricted discrete outcome regression model. function also supports continuous outcome regression lm object well glm, glm.nb, polr. example , underlying model logistic regression probability 1 \\(\\mathrm{logit}^{-1}(\\beta_0+\\beta_1 X_1+\\beta_2 X_2+\\beta_3X_1 X_2)\\), \\((\\beta_0,\\beta_1,\\beta_2,\\beta_3)=(-5,2,1,3)\\), \\(X_1\\sim N(1,1)\\), \\(X_2\\) dummy variable probability one equal 0.7. misspecified model, binary covariate interaction term omitted. #### Example figures illustrate ordered curves plots corresponding model0 model1. left panel, curve closely aligns diagonal line, indicating mean structure model0 correctly specified. contrary, model1 exhibits deviation diagonal line due omission variable \\(x_2\\). misspecification, coupled choice threshold value \\(x_2\\), results observed discrepancy ordered curve right panel. substantial disparity observed curve model1 diagonal line strongly suggests necessity including variable \\(x_2\\) model. inclusion crucial accurately capturing underlying mean structure.","code":"library(assessor) ## Binary example of ordered curve n <- 500 set.seed(1234) x1 <-rnorm(n,1,1); x2 <- rbinom(n,1,0.7) beta0 <- -5; beta1 <- 2; beta2<- 1; beta3 <- 3 q1 <-1/(1+exp(beta0+beta1*x1+beta2*x2+beta3*x1*x2)) y1 <- rbinom(n,size=1,prob = 1-q1)  par(mfrow=c(1,2)) model0 <- glm(y1~x1*x2,family =binomial(link = \"logit\") ) ord_curve(model0,thr=model0$fitted.values)  model1 <- glm(y1~x1,family =binomial(link = \"logit\") ) ord_curve(model1,thr=x2)"},{"path":"https://jhlee1408.github.io/assessor/articles/semiconti.html","id":"semicontinuous-outcome-regression-models","dir":"Articles","previous_headings":"","what":"Semicontinuous outcome regression models","title":"Semicontinuous","text":"resid_semiconti() used calculating DPIT residuals regression models semicontinuous outcomes constructing corresponding QQ-plots. Specifically, Tobit regression Tweedie regression model suitable models resid_semiconti(). suitable model objects follows: Tweedie, glm(family= tweedie()) Tobit(VGAM), VGAM::vglm() Tobit(AER), AER::tobit() Tweedie Tobit simulate y1 follow Tweedie distribution depending covariates x11 x12. constructing model2, intentional omission covariate x12 aimed facilitating direct comparison true model, model1. expected, QQ plot right panel corresponding model2 exhibits substantial deviation diagonal line, attributing deviation deliberate omission. Conversely, left panel shows closer alignment along diagonal, implying better fit including covariates, x11 x12. outcome strongly suggests incorporating covariates results appropriate improved model.  resid_semiconti() function supports calculating DPIT residuals Tobit regression VGAM::vglm AER::tobit packages. example, assume latent variable \\(Y^*\\) follows normal distribution mean given \\[\\mu=\\beta_0+\\beta_1X_1+\\beta_2X_2, \\] \\(X_1, X_2 \\sim Unif (0, 1)\\) independently, \\(\\beta_0 = 1, \\beta_1 = -3,  \\beta_2 = 3\\). observe \\(Y=0\\) \\(Y^*<0\\). variables employed inputs Tobit regression analyses provided VGAM AER packages. model fit1miss, corresponding right QQ plot, intentionally omits covariate x12. omission leads deviation diagonal line QQ plot, observed right panel. Thus, can interpreted model misspecification. contrast, left panel, corresponding model including covariates, aligns closely along diagonal line.  interpretation remains VGAM example. Note results AER exactly VGAM example.","code":"## Tweedie model library(assessor) library(tweedie) library(statmod) n <- 500 x11 <- rnorm(n) x12 <- rnorm(n) beta0 <- 5 beta1 <- 1 beta2 <- 1 lambda1 <- exp(beta0 + beta1 * x11 + beta2 * x12) y1 <- rtweedie(n, mu = lambda1, xi = 1.6, phi = 10) # True model model1 <-   glm(y1 ~ x11 + x12,     family = tweedie(var.power = 1.6, link.power = 0)   )  # missing covariate model2 <-  glm(y1 ~ x11 ,     family = tweedie(var.power = 1.6, link.power = 0)   )  par(mfrow=c(1,2)) resid1 <- resid_semiconti(model1) resid2 <- resid_semiconti(model2) ## Tobit regression model library(VGAM) beta13 <- 1 beta14 <- -3 beta15 <- 3  set.seed(123) x11 <- runif(n) x12 <- runif(n) lambda1 <- beta13 + beta14 * x11 + beta15 * x12 sd0 <- 0.3 yun <- rnorm(n, mean = lambda1, sd = sd0) y <- ifelse(yun >= 0, yun, 0) # Using VGAM package # True model fit1 <- vglm(formula = y ~ x11 + x12, tobit(Upper = Inf, Lower = 0, lmu = \"identitylink\")) # Missing covariate fit1miss <- vglm(formula = y ~ x11, tobit(Upper = Inf, Lower = 0, lmu = \"identitylink\"))  par(mfrow=c(1,2)) resid1 <- resid_semiconti(fit1, plot = TRUE) resid2 <- resid_semiconti(fit1miss, plot = TRUE) # Using AER package library(AER) # True model fit2 <- tobit(y ~ x11 + x12, left = 0, right = Inf, dist = \"gaussian\") # Missing covariate par(mfrow=c(1,2)) fit2miss <- tobit(y ~ x11, left = 0, right = Inf, dist = \"gaussian\") reisd1 <- resid_semiconti(fit2, plot = TRUE) resid2 <- resid_semiconti(fit2miss, plot = TRUE)"},{"path":"https://jhlee1408.github.io/assessor/articles/zeroinfl.html","id":"zero-inflation-regression-models","dir":"Articles","previous_headings":"","what":"Zero-Inflation regression models","title":"Zero-inflated discrete","text":"resid_zeroinfl() used calculating DPIT residuals regression models zero-inflation outcomes drawing corresponding QQ-plots. suitable model objects follows: Zero-Inflated Poisson, pscl::zeroinfl(dist = \"poisson\") Zero-Inflated negative binomial, pscl::zeroinfl(dist = \"negbin\") Zero-Inflation Poisson Zero-Inflation Negative Binomial simulate data using zero-inflated Poisson model. probability excess zeros modeled \\(\\mathrm{logit}(p_0) = \\beta_{00} + \\beta_{10}X_1\\), Poisson component mean \\(\\lambda = \\exp(\\beta_0 +\\beta_1X_1 +\\beta_2X_2)\\), \\(X_1 \\sim N(0,1)\\) \\(X_2\\) dummy variable probability 1 equal 0.7, \\(( \\beta_{00} ,\\beta_{10}, \\beta_0, \\beta_1, \\beta_2) = (-2, 2, -2, 2, 1)\\). figure illustrates QQ plots corresponding modelzero1 modelzero2. Given true underlying distribution y follows zero-inflated Poisson distribution, anticipate observing deviations diagonal line QQ plot modelzero2. expected, left QQ plot aligns closely along diagonal line. However, right panel, left right tails QQ plot modelzero2 deviate diagonal line, indicating assumption Poisson distribution may accurate. Moreover, noticeable S-shaped pattern arises due overdispersion. discrepancies observed QQ plot modelzero2 suggest Poisson distribution assumption well-supported data. finding emphasizes importance considering alternative distributional assumptions, zero-inflated Poisson distribution, may better capture characteristics simulated data. Similarly, generate zero-inflated negative binomial random variable denoted y, dependent variables x1 x2. simulation involves modeling occurrence zeros variable y zero-inflated negative binomial distribution.  figure also presents QQ plots corresponding model.negbin1 model.negbin2. contrast simulation setting, model.negbin2 assumes negative binomial distribution rather zero-inflated negative binomial distribution. Consequently, right panel figure displays deviations left right tails. deviations may substantial, comparison left panel suggests QQ plots lean towards supporting zero-inflated negative binomial regression.","code":"## Zero-Inflated Poisson library(assessor) library(pscl) n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -2 beta1 <- 2 beta2 <- 1 beta00 <- -2 beta10 <- 2  # Mean of Poisson part lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) # Excess zero probability p0 <- 1 / (1 + exp(-(beta00 + beta10 * x1))) ## simulate outcomes y0 <- rbinom(n, size = 1, prob = 1 - p0) y1 <- rpois(n, lambda1) y <- ifelse(y0 == 0, 0, y1) par(mfrow=c(1,2)) ## True model modelzero1 <- zeroinfl(y ~ x1 + x2 | x1, dist = \"poisson\", link = \"logit\") resid1 <- resid_zeroinfl(modelzero1, plot = TRUE, scale = \"uniform\")  ## Zero inflation modelzero2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid2 <- resid_disc(modelzero2, plot = TRUE, scale = \"normal\") ## Zero-inflated Negative Binomial library(assessor) library(pscl) library(MASS) n <- 500 set.seed(1234)  # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -2 beta1 <- 2 beta2 <- 1 beta00 <- -2 beta10 <- 2 size1 <- 2  # Mean of Poisson part lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) # Excess zero probability p0 <- 1 / (1 + exp(-(beta00 + beta10 * x1))) ## simulate outcomes y0 <- rbinom(n, size = 1, prob = 1 - p0) y1 <- rnbinom(n, size=size1, mu= lambda1) y <- ifelse(y0 == 0, 0, y1) model.negbin1 <- zeroinfl(y ~ x1 + x2 | x1, dist = \"negbin\") model.negbin2 <- glm.nb(y ~ x1 + x2)  par(mfrow=c(1,2)) resid.zero1 <- resid_zeroinfl(model.negbin1, plot = TRUE, scale = \"uniform\") resid.zero2 <- resid_disc(model.negbin2, plot = TRUE, scale = \"normal\")"},{"path":"https://jhlee1408.github.io/assessor/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lu Yang. Author. Jeonghwan Lee. Maintainer, author.","code":""},{"path":"https://jhlee1408.github.io/assessor/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yang L, Lee J (2024). assessor: Assessment Tools Regression Models Discrete Semicontinuous Outcomes. R package version 1.0.0, https://jhlee1408.github.io/assessor/, https://github.com/jhlee1408/assessor.","code":"@Manual{,   title = {assessor: Assessment Tools for Regression Models with Discrete and Semicontinuous Outcomes},   author = {Lu Yang and Jeonghwan Lee},   year = {2024},   note = {R package version 1.0.0, https://jhlee1408.github.io/assessor/},   url = {https://github.com/jhlee1408/assessor}, }"},{"path":[]},{"path":"https://jhlee1408.github.io/assessor/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Assessing assumptions","text":"goal assessor provide assessment tools regression models discrete semicontinuous outcomes proposed Yang (2023) Yang(2024). calculates double probability integral transform (DPIT) residuals, constructs QQ plots residuals ordered curve assessing mean structures.","code":""},{"path":"https://jhlee1408.github.io/assessor/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Assessing assumptions","text":"Install latest release CRAN: Also, can install development version assessor GitHub :","code":"install.package('assessor') # install.packages(\"devtools\") devtools::install_github(\"jhlee1408/assessor\")"},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Ordered curve for assessing mean structures — ord_curve","title":"Ordered curve for assessing mean structures — ord_curve","text":"Creates plot assess mean structure regression models. plot compares cumulative sum response variable hypothesized value. Deviation diagonal suggests possibility mean structure model incorrect.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ordered curve for assessing mean structures — ord_curve","text":"","code":"ord_curve(model, thr)"},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ordered curve for assessing mean structures — ord_curve","text":"model Regression model object (e.g.,lm, glm, glm.nb, polr, lm) thr Threshold variable (e.g., predictor, fitted values, variable included covariate)","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ordered curve for assessing mean structures — ord_curve","text":"x-axis: \\(\\hat L_1(t)\\) y-axis: \\(\\hat L_2(t)\\) defined Details.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ordered curve for assessing mean structures — ord_curve","text":"ordered curve plots $$\\hat{L}_1(t)=\\frac{\\sum_{=1}^n\\left[Y_i1(Z_i\\leq t)\\right]}{\\sum_{=1}^nY_i}$$ $$\\hat{L}_2(t)=\\frac{\\sum_{=1}^n\\left[\\hat{\\lambda}_i1(Z_i\\leq t)\\right]}{\\sum_{=1}^n\\hat{\\lambda}_i},$$ \\(\\hat{\\lambda}_i\\) fitted mean, \\(Z_i\\) threshold variable. mean structure correctly specified model, \\(\\hat L_1(t)\\) \\(\\hat L_2(t)\\) close . curve distant diagonal, suggests incorrectness mean structure. Moreover, curve diagonal, summation response larger fitted mean, implies mean underestimated, vice versa. role thr (threshold variable \\(Z\\)) determine rule  accumulating \\(\\hat{\\lambda}_i\\) \\(Y_i\\), \\(=1,\\ldots,n\\) ordered curve. candidate thr function predictors single predictor (e.g., x1), linear combination predictor (e.g., x1+x2), fitted values (e.g., fitted(model)). can also variable considered included mean function. variable  leads large discrepancy ordered curve diagonal, including variable mean function considered. details, see reference paper.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ordered curve for assessing mean structures — ord_curve","text":"Yang, Lu. \"Double Probability Integral Transform Residuals Regression Models Discrete Outcomes.\" arXiv preprint arXiv:2308.15596 (2023).","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/ord_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ordered curve for assessing mean structures — ord_curve","text":"","code":"## Binary example of ordered curve n <- 500 set.seed(1234) x1 <- rnorm(n, 1, 1) x2 <- rbinom(n, 1, 0.7) beta0 <- -5 beta1 <- 2 beta2 <- 1 beta3 <- 3 q1 <- 1 / (1 + exp(beta0 + beta1 * x1 + beta2 * x2 + beta3 * x1 * x2)) y1 <- rbinom(n, size = 1, prob = 1 - q1)  ## True Model model0 <- glm(y1 ~ x1 * x2, family = binomial(link = \"logit\")) ord_curve(model0, thr = model0$fitted.values) # set the threshold as fitted values   ## Missing a covariate model1 <- glm(y1 ~ x1, family = binomial(link = \"logit\")) ord_curve(model1, thr = x2) # set the threshold as a covariate   ## Poisson example of ordered curve n <- 500 set.seed(1234) x1 <- rnorm(n) x2 <- rnorm(n) beta0 <- 0 beta1 <- 2 beta2 <- 1 lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2)  y <- rpois(n, lambda1)  ## True Model poismodel1 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) ord_curve(poismodel1, thr = poismodel1$fitted.values)   ## Missing a covariate poismodel2 <- glm(y ~ x1, family = poisson(link = \"log\")) ord_curve(poismodel2, thr = poismodel2$fitted.values)  ord_curve(poismodel2, thr = x2)"},{"path":"https://jhlee1408.github.io/assessor/reference/qqresid.html","id":null,"dir":"Reference","previous_headings":"","what":"QQ-plots of DPIT residuals — qqresid","title":"QQ-plots of DPIT residuals — qqresid","text":"Makes QQ-plot DPIT residuals calculated resid_disc(), resid_semiconti() resid_zeroinfl(). plot close diagonal model correctly specified. Note function return residuals. get residuals QQ-plot, use resid_disc(), resid_semiconti() resid_zeroinfl().","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/qqresid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"QQ-plots of DPIT residuals — qqresid","text":"","code":"qqresid(model, scale=\"normal\")"},{"path":"https://jhlee1408.github.io/assessor/reference/qqresid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"QQ-plots of DPIT residuals — qqresid","text":"model Fitted model object (e.g., glm(), glm.nb(), zeroinfl(), polr()) scale can choose scale residuals normal uniform scales. sample quantiles residuals plotted theoretical quantiles standard normal distribution normal scale, theoretical quantiles uniform (0,1) distribution uniform scale. defalut scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/qqresid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"QQ-plots of DPIT residuals — qqresid","text":"QQ plot. x-axis: Theoretical quantiles y-axis: Sample quantiles generated DPIT residuals","code":""},{"path":[]},{"path":"https://jhlee1408.github.io/assessor/reference/qqresid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"QQ-plots of DPIT residuals — qqresid","text":"","code":"n <- 100 b <- c(2, 1, -2) x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) y <- rpois(n, exp(b[1] + b[2] * x1 + b[3] * x2))  m1 <- glm(y ~ x1 + x2, family = poisson) qqresid(m1, scale = \"normal\")  qqresid(m1, scale = \"uniform\")"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for regression models with two-part outcomes — resid_2pm","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"Calculates DPIT proposed residuals model semi-continuous outcomes. resid_2pm can used either model0 model1 part0 part1 arguments.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"","code":"resid_2pm(model0, model1, y, part0, part1, plot=TRUE, scale = \"normal\")"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"model0 Model object 0 outcomes (e.g., logistic regression) model1 Model object continuous part (gamma regression) y Semicontinuous outcome variables part0 Alternative argument model0. One can supply sequence probabilities \\(P(Y_i=0),~=1,\\ldots,n\\). part1 Alternative argument model1. One can fit regression model positive data supply probability integral transform. Note length part1 number positive values y can shorter part0. plot logical value indicating whether return QQ-plot scale can choose scale residuals among normal uniform scales. default scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"Residuals. plot=TRUE, also produces QQ plot.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"DPIT residuals regression models semi-continuous outcomes $$\\hat{r}_i=\\frac{\\hat{F}(Y_i|\\mathbf{X}_i)}{n}\\sum_{j=1}^n1\\left(\\hat{p}_0(\\mathbf{X}_j)\\leq \\hat{F}(Y_i|\\mathbf{X}_i)\\right), =1,\\ldots,n,$$ \\(\\hat{p}_0(\\mathbf{X}_i)\\) fitted probability zero, \\(\\hat{F}(\\cdot|\\mathbf{X}_i)\\)  fitted cumulative distribution function \\(\\)th observation. Furthermore, $$\\hat{F}(y|\\mathbf{x})=\\hat{p}_0(\\mathbf{x})+\\left(1-\\hat{p}_0(\\mathbf{x})\\right)\\hat{G}(y|\\mathbf{x})$$ \\(\\hat{G}\\) fitted cumulative distribution positive data. two-part models, probability zero can modeled using logistic regression, model0, positive observations can modeled using gamma regression, model1. Users can choose use different models supply resulting probability transforms. part0 sequence fitted probabilities zeros \\(\\hat{p}_0(\\mathbf{X}_i) ,~=1,\\ldots,n\\). part1 probability integral transform positive part \\(\\hat{G}(Y_i|\\mathbf{X}_i)\\). Note length part1 number positive values y can shorter part0.","code":""},{"path":[]},{"path":"https://jhlee1408.github.io/assessor/reference/resid_2pm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for regression models with two-part outcomes — resid_2pm","text":"","code":"library(MASS) n <- 500 beta10 <- 1 beta11 <- -2 beta12 <- -1 beta13 <- -1 beta14 <- -1 beta15 <- -2 x11 <- rnorm(n) x12 <- rbinom(n, size = 1, prob = 0.4)  p1 <- 1 / (1 + exp(-(beta10 + x11 * beta11 + x12 * beta12))) lambda1 <- exp(beta13 + beta14 * x11 + beta15 * x12) y2 <- rgamma(n, scale = lambda1 / 2, shape = 2) y <- rep(0, n) u <- runif(n, 0, 1) ind1 <- which(u >= p1) y[ind1] <- y2[ind1]  # models as input mgamma <- glm(y[ind1] ~ x11[ind1] + x12[ind1], family = Gamma(link = \"log\")) m10 <- glm(y == 0 ~ x12 + x11, family = binomial(link = \"logit\")) resid.model <- resid_2pm(model0 = m10, model1 = mgamma, y = y)  # PIT as input cdfgamma <- pgamma(y[ind1],   scale = mgamma$fitted.values * gamma.dispersion(mgamma),   shape = 1 / gamma.dispersion(mgamma) ) p1f <- m10$fitted.values resid.pit <- resid_2pm(y = y, part0 = p1f, part1 = cdfgamma)"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for regression models with discrete outcomes — resid_disc","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"Calculates DPIT residuals regression models discrete outcomes. Specifically, model assumption GLMs binary, ordinal, Poisson, negative binomial outcomes can assessed using resid_disc().","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"","code":"resid_disc(model, plot=TRUE, scale=\"normal\")"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"model Model object (e.g., glm, glm.nb, polr) plot logical value indicating whether return QQ-plot scale can choose scale residuals among normal uniform scales. sample quantiles residuals plotted theoretical quantiles standard normal distribution normal scale, theoretical quantiles uniform (0,1) distribution uniform scale. defalut scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"DPIT residuals. plot=TRUE, also produces QQ plot.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"DPIT residual \\(\\)th observation defined follows: $$\\hat{r}(Y_i|X_i) = \\hat{G}\\bigg(\\hat{F}(Y_i|\\mathbf{X}_i)\\bigg)$$ $$\\hat{G}(s) = \\frac{1}{n-1}\\sum_{j=1, j \\neq }^{n}\\hat{F}\\bigg(\\hat{F}^{(-1)}(\\mathbf{X}_j)\\bigg|\\mathbf{X}_j\\bigg)$$ \\(\\hat{F}\\) refers fitted cumulative distribution function. scale=\"uniform\", DPIT residuals closely follow uniform distribution, otherwise implies model deficiency. scale=\"normal\", applies normal quantile transformation DPIT residuals $$\\Phi^{-1}\\left[\\hat{r}(Y_i|\\mathbf{X}_i)\\right],=1,\\ldots,n.$$ null pattern standard normal distribution case. Check reference details.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"Yang, Lu. \"Double Probability Integral Transform Residuals Regression Models Discrete Outcomes.\" arXiv preprint arXiv:2308.15596 (2023).","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_disc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for regression models with discrete outcomes — resid_disc","text":"","code":"library(MASS) n <- 500 set.seed(1234) ## Negative Binomial example # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) ### Parameters beta0 <- -2 beta1 <- 2 beta2 <- 1 size1 <- 2 lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) # generate outcomes y <- rnbinom(n, mu = lambda1, size = size1)  # True model model1 <- glm.nb(y ~ x1 + x2) resid.nb1 <- resid_disc(model1, plot = TRUE, scale = \"uniform\")   # Overdispersion model2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid.nb2 <- resid_disc(model2, plot = TRUE, scale = \"normal\")   ## Binary example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n, 1, 1) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -5 beta1 <- 2 beta2 <- 1 beta3 <- 3 q1 <- 1 / (1 + exp(beta0 + beta1 * x1 + beta2 * x2 + beta3 * x1 * x2)) y1 <- rbinom(n, size = 1, prob = 1 - q1)  # True model model01 <- glm(y1 ~ x1 * x2, family = binomial(link = \"logit\")) resid.bin1 <- resid_disc(model01, plot = TRUE)   # Missing covariates model02 <- glm(y1 ~ x1, family = binomial(link = \"logit\")) resid.bin2 <- resid_disc(model02, plot = TRUE)   ## Poisson example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -2 beta1 <- 2 beta2 <- 1 lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) y <- rpois(n, lambda1)  # True model poismodel1 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid.poi1 <- resid_disc(poismodel1, plot = TRUE)   # Enlarge three outcomes y <- rpois(n, lambda1) + c(rep(0, (n - 3)), c(10, 15, 20)) poismodel2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid.poi2 <- resid_disc(poismodel2, plot = TRUE)   ## Ordinal example n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n, mean = 2) # Coefficient beta1 <- 3  # True model p0 <- plogis(1, location = beta1 * x1) p1 <- plogis(4, location = beta1 * x1) - p0 p2 <- 1 - p0 - p1 genemult <- function(p) {   rmultinom(1, size = 1, prob = c(p[1], p[2], p[3])) } test <- apply(cbind(p0, p1, p2), 1, genemult) y1 <- rep(0, n) y1[which(test[1, ] == 1)] <- 0 y1[which(test[2, ] == 1)] <- 1 y1[which(test[3, ] == 1)] <- 2 multimodel <- polr(as.factor(y1) ~ x1, method = \"logistic\") resid.ord1 <- resid_disc(multimodel, plot = TRUE)   ## Non-Proportionality n <- 500 set.seed(1234) x1 <- rnorm(n, mean = 2) beta1 <- 3 beta2 <- 1 p0 <- plogis(1, location = beta1 * x1) p1 <- plogis(4, location = beta2 * x1) - p0 p2 <- 1 - p0 - p1 genemult <- function(p) {   rmultinom(1, size = 1, prob = c(p[1], p[2], p[3])) } test <- apply(cbind(p0, p1, p2), 1, genemult) y1 <- rep(0, n) y1[which(test[1, ] == 1)] <- 0 y1[which(test[2, ] == 1)] <- 1 y1[which(test[3, ] == 1)] <- 2 multimodel <- polr(as.factor(y1) ~ x1, method = \"logistic\") resid.ord2 <- resid_disc(multimodel, plot = TRUE)"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"Calculates DPIT residuals regression models semi-continuous outcomes. semi-continuous regression model Tweedie regression model tweedie package Tobit regression model VGAM, AER packages used function.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"","code":"resid_semiconti(model, plot=TRUE, scale = \"normal\")"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"model Model object (e.g., tweedie, vglm, tobit) plot logical value indicating whether return QQ-plot scale can choose scale residuals normal uniform scales. default scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"Residuals. plot=TRUE, also produces QQ plot.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"DPIT residual \\(\\)th semicontinuous observation defined follows: $$\\hat{r}_i = \\frac{\\hat{F}(Y_i|X_i)}{n}\\sum_{j=1}^{n}\\bigg(\\hat{p}_0(X_j) \\leq \\hat{F}(Y_i|X_i)\\bigg),$$ null distribution uniformity. \\(\\hat{F}\\) refers fitted cumulative distribution function, \\(\\hat{p}_0\\) refers fitted probability zero.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"Lu Yang (2024). Diagnostics Regression Models Semicontinuous Outcomes, Biometrics, https://arxiv.org/abs/2401.06347","code":""},{"path":[]},{"path":"https://jhlee1408.github.io/assessor/reference/resid_semiconti.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for regression models with semicontinuous outcomes — resid_semiconti","text":"","code":"## Tweedie model library(tweedie) library(statmod) n <- 500 x11 <- rnorm(n) x12 <- rnorm(n) beta0 <- 5 beta1 <- 1 beta2 <- 1 lambda1 <- exp(beta0 + beta1 * x11 + beta2 * x12) y1 <- rtweedie(n, mu = lambda1, xi = 1.6, phi = 10) # Choose parameter p # True model model1 <-   glm(y1 ~ x11 + x12,     family = tweedie(var.power = 1.6, link.power = 0)   ) resid.tweedie <- resid_semiconti(model1)   ## Tobit regression model library(VGAM) #> Loading required package: stats4 #> Loading required package: splines beta13 <- 1 beta14 <- -3 beta15 <- 3  set.seed(1234) x11 <- runif(n) x12 <- runif(n) lambda1 <- beta13 + beta14 * x11 + beta15 * x12 sd0 <- 0.3 yun <- rnorm(n, mean = lambda1, sd = sd0) y <- ifelse(yun >= 0, yun, 0)  # Using VGAM package # True model fit1 <- vglm(formula = y ~ x11 + x12, tobit(Upper = Inf, Lower = 0, lmu = \"identitylink\")) # Missing covariate fit1miss <- vglm(formula = y ~ x11, tobit(Upper = Inf, Lower = 0, lmu = \"identitylink\"))  resid.tobit1 <- resid_semiconti(fit1, plot = TRUE)  resid.tobit2 <- resid_semiconti(fit1miss, plot = TRUE)  # Using AER package library(AER) #> Loading required package: car #> Loading required package: carData #>  #> Attaching package: ‘car’ #> The following object is masked from ‘package:VGAM’: #>  #>     logit #> Loading required package: lmtest #> Loading required package: zoo #>  #> Attaching package: ‘zoo’ #> The following objects are masked from ‘package:base’: #>  #>     as.Date, as.Date.numeric #>  #> Attaching package: ‘lmtest’ #> The following object is masked from ‘package:VGAM’: #>  #>     lrtest #> Loading required package: sandwich #> Loading required package: survival #>  #> Attaching package: ‘AER’ #> The following object is masked from ‘package:VGAM’: #>  #>     tobit  # True model fit2 <- tobit(y ~ x11 + x12, left = 0, right = Inf, dist = \"gaussian\") # Missing covariate fit2miss <- tobit(y ~ x11, left = 0, right = Inf, dist = \"gaussian\") resid.aer1 <- resid_semiconti(fit2, plot = TRUE) #> Error in resid_semiconti(fit2, plot = TRUE): object 'y' not found resid.aer2 <- resid_semiconti(fit2miss, plot = TRUE) #> Error in resid_semiconti(fit2miss, plot = TRUE): object 'y' not found"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"Caluates DPIT residuals regression model zero-inflated discrete outcome. zero-inflated model pscl used function.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"","code":"resid_zeroinfl(model, plot=TRUE, scale='normal')"},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"model Model object, output pscl::zeroinfl. plot logical value indicating whether return QQ-plot. scale can choose scale residuals among normal uniform scales. default scale normal.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"DPIT residuals. plot=TRUE, also produces QQ plot.","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"Yang, Lu. \"Double Probability Integral Transform Residuals Regression Models Discrete Outcomes.\" arXiv preprint arXiv:2308.15596 (2023).","code":""},{"path":"https://jhlee1408.github.io/assessor/reference/resid_zeroinfl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals for regression models with zero-inflated outcomes — resid_zeroinfl","text":"","code":"## Zero-Inflated Poisson library(pscl) #> Classes and Methods for R originally developed in the #> Political Science Computational Laboratory #> Department of Political Science #> Stanford University (2002-2015), #> by and under the direction of Simon Jackman. #> hurdle and zeroinfl functions by Achim Zeileis. n <- 500 set.seed(1234) # Covariates x1 <- rnorm(n) x2 <- rbinom(n, 1, 0.7) # Coefficients beta0 <- -2 beta1 <- 2 beta2 <- 1 beta00 <- -2 beta10 <- 2  # Mean of Poisson part lambda1 <- exp(beta0 + beta1 * x1 + beta2 * x2) # Excess zero probability p0 <- 1 / (1 + exp(-(beta00 + beta10 * x1))) ## simulate outcomes y0 <- rbinom(n, size = 1, prob = 1 - p0) y1 <- rpois(n, lambda1) y <- ifelse(y0 == 0, 0, y1) ## True model modelzero1 <- zeroinfl(y ~ x1 + x2 | x1, dist = \"poisson\", link = \"logit\") resid.zero1 <- resid_zeroinfl(modelzero1, plot = TRUE, scale = \"uniform\")   ## Zero inflation modelzero2 <- glm(y ~ x1 + x2, family = poisson(link = \"log\")) resid.zero2 <- resid_disc(modelzero2, plot = TRUE, scale = \"normal\")"}]
